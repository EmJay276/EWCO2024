import numpy as np


def moment2force(vertex_coords: np.ndarray,
                 moment: np.ndarray,
                 center: np.ndarray = None,
                 weights: np.ndarray = None,
                 force_compensation: bool = True) -> np.ndarray:
    """
    Calculates the external force vector based on the vertex coordinates and the moment vector.
    Optionally the center of gravity and weights can be supplied.

    Args:
        vertex_coords (np.ndarray): Coordinates of the vertices, shape = (N_VERTICES, 3)
        moment (np.ndarray):  Moment applied to the vertices (Mx, My, Mz), shape = (3,)
        center (np.ndarray): Center of gravity, needed for calculating the nodal forces
            from moment, shape = (3,), default: Center of the vertices using their weights.
        weights (np.ndarray):  Weights for each vertex, default: 1 (Equal weighting for each vertex)
        force_compensation (bool): Compensate forces generated by the moment, default: True

    Returns:
        np.ndarray: External force vector for each vertex, shape = (N_VERTICES, 3)

    """
    # default values
    if weights is None:
        weights = np.ones(vertex_coords.shape[0], dtype=float)
    if center is None:
        center = np.average(vertex_coords, axis=0, weights=weights)

    # location vector from center of gravity
    r_K0 = vertex_coords - center

    # inertia tensor
    theta = (np.einsum('n,ni,ni->', weights, r_K0, r_K0,
                       optimize=['einsum_path', (1, 2), (0, 1)]) * np.eye(3) -
             np.einsum('n,ni,nk->ik', weights, r_K0, r_K0,
                       optimize=['einsum_path', (0, 1), (0, 1)]))
    # transformation matrix to the main axes of inertia - K0 --> K1
    T01, _, _ = np.linalg.svd(theta, hermitian=True)
    # transform coordinates and moment to the main axes of inertia system - K1
    m_K1 = T01.T @ moment
    r_K1 = r_K0 @ T01  # equivalent to (T01.T @ r_K0.T).T

    # levi-civita arrangement of r_K1 to get direction vectors normal to moment
    R_K1 = np.cross(r_K1[:, None, :], np.eye(3))
    # moment divided by squared sum of all vectors
    r_K1_sq = weights @ np.square(r_K1)
    # first row of matrix A
    # 2.6 times faster to calculate (r1^2 + r2^2 + r3^2) - [r1^1, r2^2, r3^2]
    A = m_K1 / (r_K1_sq.sum() - r_K1_sq)
    # nodal forces
    f_K1 = (weights[:, None, None] * R_K1) @ A

    # debug output
    print(f"Input moment: {moment}")
    print(f"Resulting forces without compensation: {np.linalg.det(T01) * f_K1.sum(axis=0) @ T01.T}")

    # cancel out resulting total force
    if force_compensation:
        f_K1 += np.linalg.lstsq(r_K1.T, - f_K1.sum(axis=0), rcond=-1)[0][:, None] * r_K1

    # transformation back to K0
    f_K0 = np.linalg.det(T01) * (f_K1 @ T01.T)

    # debug output
    print(f"Resulting moment: {np.cross(r_K0, f_K0, axis=1).sum(axis=0)}")
    print(f"Resulting forces: {f_K0.sum(axis=0)}")
    print(f"Resulting forces relative to total forces [in %]: {f_K0.sum(axis=0) / np.abs(f_K0).sum(axis=0) * 100}")

    return f_K0
